{"root":{"data":{"id":"d3jhp13ru7k0","created":1724030184823,"text":"A Studio"},"children":[{"data":{"id":"d3jhpcnr1600","created":1724030209976,"text":"Profiling"},"children":[{"data":{"id":"d3jhpgycu4w0","created":1724030219324,"text":"CPU profiler","font-weight":"bold"},"children":[{"data":{"id":"d3jj6fo4zzc0","created":1724034369830,"text":"Display CPU profile","expandState":"expand"},"children":[{"data":{"id":"d3jio53zek00","created":1724032936289,"text":"System Trace","note":"Captures fine-grained details that allow you to inspect how your app interacts with system resources."},"children":[]},{"data":{"id":"d3jiotvotpc0","created":1724032990207,"text":"Method and function traces","note":"For each thread in your app process, you can find out which methods (Java) or functions (C/C++) are executed over a period of time, and the CPU resources each method or function consumes during its execution. "},"children":[]}]},{"data":{"id":"d3jj6wp421c0","created":1724034406895,"text":"Record traces"},"children":[{"data":{"id":"d3jj7aujrs00","created":1724034437698,"text":"Choose a recording configuration","note":"1. Sample Java Methods\n2. Trace Java Methods\n3. Sample C/C++ Functions\n4. Trace System Calls"},"children":[]},{"data":{"id":"d3jjabny4io0","created":1724034674568,"text":"Create, edit, or view a recording configuration","note":"1. Trace Technology.\n2. Sampling interval\n3. File size limit"},"children":[]},{"data":{"id":"d3jjbc7mmio0","created":1724034754123,"text":"Record CPU activity with the Debug API","note":"1. The CPU Profiler begins recording when your app calls startMethodTracing(String tracePath)\n2. The CPU Profiler stops recording when your app calls stopMethodTracing(). \n\nWhile recording CPU activity that’s triggered using this API, the CPU profiler shows Debug API as the active CPU recording configuration."},"children":[]},{"data":{"id":"d3jjf0kwjiw0","created":1724035042261,"text":"Record CPU activity during app startup"},"children":[]}]},{"data":{"id":"d3jjfmzf4mg0","created":1724035091028,"text":"Export traces"},"children":[]},{"data":{"id":"d3jji95udyo0","created":1724035296033,"text":"Import traces","note":"You can import .trace files created with the Debug API or CPU Profiler.\n\nImport your trace file by clicking Start new profiler session  in the profiler’s Sessions pane and then selecting Load from file."},"children":[]},{"data":{"id":"d3jjkukwekw0","created":1724035499385,"text":"Inspect traces"},"children":[{"data":{"id":"d3jjl8bzjfs0","created":1724035529321,"text":" using the Call Chart"},"children":[]},{"data":{"id":"d3jjnv9rezk0","created":1724035735980,"text":"using the Flame Chart tab"},"children":[]},{"data":{"id":"d3jjq6cwlag0","created":1724035916844,"text":"using Top Down and Bottom Up"},"children":[]},{"data":{"id":"d3jjwwtuj280","created":1724036444649,"text":" using the Events table"},"children":[]},{"data":{"id":"d3jk02qgl080","created":1724036692598,"text":"Inspect callstack frames"},"children":[]}]}]},{"data":{"id":"d3jhpjqaai00","created":1724030225367,"text":"Memory profiler"},"children":[]},{"data":{"id":"d3jhq6iplu80","created":1724030274975,"text":"Energy profiler","font-weight":"bold"},"children":[]},{"data":{"id":"d3jhwt2wtew0","created":1724030794270,"text":"Profileable","note":"<profileable android:shell=\"true\"/> added within the <application> section of the manifest file."},"children":[{"data":{"id":"d3ji20esezk0","created":1724031202047,"text":"automatically","expandState":"expand"},"children":[{"data":{"id":"d3jhylb8d9s0","created":1724030934087,"text":"Profile 'app' with low overhead","font-weight":"bold","note":"CPU and Memory profilers. In the Memory profiler, only Record Native Allocations is enabled."},"children":[]},{"data":{"id":"d3jhycn2ggg0","created":1724030915212,"text":"Profile 'app' with complete data ","font-weight":"bold","note":"starts the CPU, Memory, and Energy profilers"},"children":[]}]},{"data":{"id":"d3ji22pjy0g0","created":1724031207051,"text":"manually","note":"1. First build a release application\n2. then update its manifest file, which turns the release application into a profileable application.\n3. After you configure the profileable application, launch the profiler and select a profileable process to analyze."},"children":[]}]},{"data":{"id":"d3ji6fdd3kg0","created":1724031548069,"text":"Profile a profileable app","note":"1. From the development emulator or device, start the app.\n\n2. In Android Studio, launch the profiler by selecting View > Tool Windows > Profiler.\n\n3. After the application has launched, click the Profilers plus button button in the profiler to see the dropdown menu. Select your device, then select the application's entry under Other profileable processes.\n\n4. The profiler should attach to the application. Only the CPU and Memory Profilers are available, with limited capabilites for the Memory Profiler."},"children":[{"data":{"id":"d3jii7rk4400","created":1724032471883,"text":"Sessions","note":"You can save Profiler data as sessions, which are retained until you quit Android Studio. By recording profiling information in multiple sessions and switching between them, you can compare resource usage in various scenarios.\n\n1. To start a new session, click the Start a new profiling session  button and select an app process from the dropdown menu that appears.\n\n2. When you record a trace or capture a heap dump, Android Studio adds that data (along with your app's network activity) as a separate entry to the current session.\n\n3. To stop adding data to the current session, click Stop the current profiling session .\n\n4. To import a trace exported from a previous run of Android Studio, click Start new profiler session  and choose Load from file.\n\n"},"children":[]}]}]},{"data":{"id":"d3jhqw5dwmg0","created":1724030330765,"text":"Jetpack Benchmark libraries","layout_mind_offset":{"x":416.99998757243196,"y":360.9999892413621}},"children":[{"data":{"id":"d3jhrh8l3fs0","created":1724030376671,"text":"Macrobenchmark","font-weight":"bold","layout_right_offset":{"x":461.9999862313274,"y":-7.999999761581535},"note":"important performance use cases:\n1. application startup\n2. redrawing triggered by actions such as UI animations or scrolling"},"children":[]},{"data":{"id":"d3jhrniqohk0","created":1724030390346,"text":"Microbenchmark","font-weight":"bold","layout_right_offset":{"x":478.9999857246877,"y":13.999999582767487},"note":"Measure CPU cost of specific functions"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}